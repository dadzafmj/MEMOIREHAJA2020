%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%									   Chapitre 4	    								 %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Programmation et réalisation du logiciel}
\minitoc
\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}
Après avoir franchi l'étape de la modélisation, on peut désormais entamer la programmation et la réalisation du système. Dans cette partie, on abordera en premier lieu la description de notre \gls{sgbd} ainsi que les langages de programmation utilisés et par la suite on présentera les démarches de conception pour l'implémentation du système. 

\section{Les Systèmes de Gestion de Base de Données (SGBD)}
\subsection{Définition}
Les \gls{sgbd} sont des logiciels système destinés à stocker et à partager des informations dans une base de données, en garantissant la qualité, la pérennité et la confidentialité des informations, tout en cachant la complexité des opérations. En bref c'est un logiciel intermédiaires entre les utilisateurs et les bases de données. Une base de données est un magasin de données composé de plusieurs fichiers manipulés exclusivement par le \gls{sgbd}. Ce dernier cache la complexité de manipulation des structures de la base de données en mettant à disposition une vue synthétique du contenu.
\medskip

\subsection{Firebase}
Firebase est à la fois un SGBD et un ensemble de services d'hébergement pour n'importe quel type d'application (Web service, Android, iOS, Javascript, Node.js, Java, Unity, PHP, C++ ...). Il propose d'héberger en NoSQL et en temps réel des bases de données, du contenu, de l'authentification sociale (Google, Facebook, Twitter et Github), et des notifications, ou encore des services, tel que par exemple un serveur de communication temps réel \cite{firebaseWiki}.

\subsection{Pourquoi le choix de Firebase}
Lorsqu'on développe une application, qu'elle soit destinée au grand public ou réservée à un usage interne à l'entreprise, certaines fonctionnalités sont systématiquement requises, telles que la gestion des utilisateurs, de la connexion et des notifications. La gestion de ces fonctionnalités est fastidieuse, répétitive si le système se compose de plusieurs applications, et critiques en termes de sécurité, dans la mesure où l'on va stocker des mots de passe. D'où l'intervention de Firebase qui va nous permettre d'externaliser cette gestion.

\section{Les langages de programmation}
La présentation des langages de programmation sont des facteurs importants pour la réussite de la conception et la réalisation d'un logiciel. En effet, chaque langage a ses propres caractéristiques qui doivent être compatibles avec les contraintes et conditions exigées par le cahier des charges. Le choix doit être fait en fonction de leur souplesse, leur adaptation aux fonctions exigées et aux ressources matérielles disponibles.

\subsection{De JSF à Angular}
Au début nous avons utiliser le langage "Multi-end" : JSF (Java Server Faces), qui est un framework MVC (Modèle Vue Controleur) Java traditionnels à base d'actions et basé sur la notion de composants. Mais en allant plus loin dans les détails, nous pouvons en déduire des principaux inconvénients qui ont empêchés la progression du développement de l'application.
\medskip

Deux inconvénients majeurs JSF : 

\begin{enumerate}
	\item Grande courbe d'apprentissage. JSF est complexe, c'est juste vrai.
	\item Sa nature composante. Le framwork basé sur les composants essaye de cacher la vraie nature du Web, qui vient avec une énorme quantité de complications et de désastres (comme ne pas soutenir GET dans JSF). Chaque framework basé sur des composants ajoute de l'abstraction au développement Web, et cette abstraction se traduit par un surcoût inutile et une complexité plus élevée.
\end{enumerate}

En bref, JSF essaient de cacher au programmeur la vrai requête/réponse et la nature sans état du web. C'est un désavantage majeur pour JSF, certe il peut convenir à certains types d'applications (intranet, formulaires intensifs), mais pour une application web réelle, ce n'est pas une bonne solution.

\subsection{Angular}
Après avoir été bloqué avec JSF, on a recommencer le développement avec Angular,  un langage fessant partie de la nouvelle vague de frameworks JavaScript portée par Google. C'est un socle technique qui se veut extensible et qui pousse vers un développement structuré. Il s'inscrit dans un mouvement d'innovation côté front-end, dont le but est d'éviter le chargement d'une nouvelle page à chaque action demandée \cite{angularBlog}.
\medskip

Angular présente la particularité d'être totalement frontend (côté client). Pour utiliser Angular dans notre application, nous allons devoir utiliser un système backend (côté serveur), dans notre cas ce sera Firebase pour gérer la connexion à la base de données. En utilisant ce langage, on voit clairement la distinction de développement entre front et back.

\subsection{Une navigation plus fluide pour le visiteur}
L'utilisation d'Angular impose un développement selon la structure MVVM (Modèle-Vue-Vue-Modèle). Ce principe offre un avantage de taille, celui de diminuer considérablement la vitesse de chargement des pages. En effet, le nombre d'accès au serveur est fortement diminué car la communication se fait majoritairement en mode asynchrone. Autrement dit, l'interface visuelle est portée côté client. En conséquence, une importante partie des requêtes supportées en arrière-plan est ainsi supprimée, ce qui permet de concevoir des applications web plus légères. Ceci explique sa parfaite adaptation pour les applications web monopage (SPA) qui ne comportent qu'une seule et unique interface.

\subsection{Une meilleure gestion de contenu dynamique}
Le framework estampillé Google étend le langage HTML traditionnel pour enrichir davantage le contenu dynamique par le biais d'un couplage bidirectionnel (two-way data-binding). Derrière ce nom barbare se cache un concept très pratique : dès qu'une vue est modifiée, la donnée est envoyée au model associé qui rafraîchit à son tour la vue. Concrètement, si un internaute remplit un champ texte, la valeur saisie peut s'afficher à un autre endroit de la page et ce sans rechargement ni soumission au préalable de l'information. Il s'agit donc d'une synchronisation entre le modèle et la vue qui permet de créer des applications plus responsives \cite{angularNinja}.

\subsection{Une plateforme extensible et modulaire}
Pour pallier à la nature statique de la solution HTML, Angular introduit la notion de directives chargée d'associer un comportement JavaScript spécifique à chaque nouvel élément de ce langage balisé. Ces composants vont permettre de rendre le code extensible et modulable. Il devient alors facile d'ajouter, de modifier ou de supprimer des directives, ce qui fait entre autre la popularité d'Angular. Celles-ci peuvent tout-à-fait être partagées et réutilisées de projet en projet pour éviter de réinventer la roue \cite{angular2StepbyStep}.

\subsection{Présentation en HTML5/CSS3/JS/jQuery}
Pour afficher, mettre en forme et structurer les données à l'utilisateur, nous utilisons les langages HTML (\glsentrylong{html}), le CSS (\glsentrylong{css}) et éventuellement le Javascript (JS) pour l'interactivité de l'application. Ceux-ci ont une caractéristique commune importante : ils sont tous interprétés par le navigateur, directement sur la machine client.
\medskip

L'utilisation de jQuery est aussi un atout, c'est une bibliothèque JavaScript libre et multi-plateforme créée pour faciliter l'écriture de scripts côté client dans le code HTML. \\
Cette bibliothèque va nous servir notamment au fonctionnalités suivantes:
\begin{itemize}
	\item [\textbullet] Manipulation des feuilles de style en cascade (ajout/suppression des classes, d'attributs...);
	\item [\textbullet] Événements;
	\item [\textbullet] Effets visuels et animations ;
\end{itemize}

\section{Conception}
\subsection{Création du projet}
Nous devons avant tout installé Node et npm.
Ensuite pour installer angular CLI, il suffit de taper la commande suivante dans votre bash :

\begin{verbatim}
npm install -g @angular/cli
\end{verbatim}

Pour crée maintenant notre application, il suffit d'exécuter la commande suivante :

\begin{verbatim}
ng new g4sm
\end{verbatim}

\subsection{La structure des dossiers}
Après l'installation et la création de votre projet avec angular-cli, nous allons voir la structure des dossiers et fichiers dans l'architecture d'angular-cli.

\begin{verbatim}
	// Tout ce qui va concerner les tests end to end
	|- e2e/
	|----- app.e2e-spec.ts
	|----- app.po.ts
	|----- tsconfig.e2e.json
	
	// les dépendances avec npm
	|- node_modules/
	
	// l'endroit où les fichiers de build seront mis
	|- dist/
	
	// Le dossier où vous allez modifier vos fichiers de code
	//Là où va se trouver vos composants, services, etc..
	|- src/
	|----- app/
	|----- app.component.css|html|spec.ts|ts
	|----- app.module.ts
	|----- assets/
	|----- environments/
	|----- environment.prod.ts|ts
	|----- favicon.ico
	|----- index.html
	|----- main.ts
	|----- polyfills.ts
	|----- styles.css
	|----- test.ts
	|----- tsconfig.app.json
	|----- tsconfig.spec.json
	|----- typings.d.ts
	
	// la configuration globale de votre application
	|- .angular-cli.json  // the main configuration file
	|- .editorconfig      // editorconfig which is used in some VS Code setups
	|- .gitignore
	|- karma.conf.js
	|- package.json
	|- protractor.conf.js
	|- README.md
	|- tsconfig.json
	|- tslint.json
\end{verbatim}

Nous allons quasiment passer tout notre temps dans le dossier \emph{src/app}. Ce dossier contient presque tous les fichiers dont nous avons besoin pour coder notre application. Les fichiers contenus dans ce dossier sont ensuite compilés dans le dossier \emph{dist}.  Nous pouvons aussi installer des dépendances avec le gestionnaire de package de node : "npm". Ces dépendances seront installées dans le dossier "node modules".

\subsection{Firebase Realtime Database, une base de données en temps réel}
La base de données avec Firebase se présente sous la forme d'un arbre “infini”, composé uniquement d'objets clé/valeur. Il s'agit d'une base de données cloud où les données sont stockées sous format JSON (JavaScript Object Notation) et synchronisées en temps réel avec chaque client connecté. Par exemple, si on souhaite stocker un ensemble d'utilisateur, cela devrait plus ou moins ressembler à cela :

\begin{verbatimtab}[3]
{
	"utilisateurs": {
		"id1": {
			"nom": "Midonique",
			"email": "mido@gmail.com",
		},
		"id2": { ... },
		"id3": { ... }
	}
}
\end{verbatimtab}

\clearpage
\subsection{Sécurisation des données}
Pour faire simple : l'accès aux données présentes dans la base est régi par un ensemble de règles. Établissons un simple fichier de règles pour nos utilisateurs :

\begin{verbatimtab}[3]
{
	"rules": {
		".read": "auth != null",
		".write": "auth != null"
	}
}
\end{verbatimtab}

C'est uniquement un utilisateur connecté pourra lire, enregistrer et modifer ces données. Il s’agit évidemment ici d’un exemple simple : nous pouvez établir des règles de sécurité bien plus complexes afin de protéger les données des utilisateurs.
